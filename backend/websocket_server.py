"""
WebSocket server for real-time EEG data streaming
"""
import asyncio
import websockets
import json
import sys
import os
from typing import Set
from datetime import datetime, timezone
from brainflow.board_shim import BoardIds, BoardShim
from brainflow.board_shim import BrainFlowInputParams

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from backend.eeg_service import EEGService


class WebSocketServer:
    """WebSocket server to stream EEG data to frontend"""
    
    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        # Use synthetic board for autogenerated data (can be overridden with environment variable)
        board_id = int(os.getenv("BOARD_ID", BoardIds.SYNTHETIC_BOARD))
        self.eeg_service = EEGService(board_id=board_id)
        self.connected_clients: Set = set()
        self.current_context = {}
        self.current_user_id = "default"
        self.stream_task = None
    
    async def register_client(self, websocket):
        """Register a new client"""
        self.connected_clients.add(websocket)
        print(f"[CLIENT] Client connected. Total clients: {len(self.connected_clients)}")
        print(f"[CLIENT] WebSocket object: {websocket}, Remote: {getattr(websocket, 'remote_address', 'N/A')}")
        
        # Send current state to new client
        try:
            await websocket.send(json.dumps({
                "type": "state_sync",
                "is_recording": self.eeg_service.is_streaming,
            }))
            print(f"[CLIENT] State sync message sent successfully")
        except Exception as e:
            print(f"[CLIENT] Error sending state sync: {e}")
            self.connected_clients.discard(websocket)
    
    async def unregister_client(self, websocket):
        """Unregister a client"""
        self.connected_clients.discard(websocket)
        print(f"Client disconnected. Total clients: {len(self.connected_clients)}")
    
    async def broadcast(self, message: dict):
        """Broadcast message to all connected clients"""
        if not self.connected_clients:
            return
        
        message_str = json.dumps(message)
        disconnected = set()
        sent_count = 0
        
        for client in self.connected_clients.copy():  # Use copy to avoid modification during iteration
            try:
                await client.send(message_str)
                sent_count += 1
            except websockets.exceptions.ConnectionClosed:
                disconnected.add(client)
            except Exception as e:
                print(f"[BROADCAST] Error sending to client: {e}")
                disconnected.add(client)
        
        # Remove disconnected clients
        for client in disconnected:
            self.connected_clients.discard(client)
    
    async def handle_message(self, websocket, message: str):
        """Handle incoming messages from clients"""
        try:
            data = json.loads(message)
            msg_type = data.get("type")
            
            if msg_type == "set_mental_state":
                # Set mental state mode for data generation (calm/stressed/normal)
                mode = data.get("mode", "normal")
                print(f"[WS] Setting mental state mode to: {mode}")
                
                if mode in ["calm", "stressed", "normal"]:
                    # Set the mode
                    self.eeg_service.set_mental_state_mode(mode)
                    
                    # Send confirmation
                    try:
                        await websocket.send(json.dumps({
                            "type": "mental_state_changed",
                            "mode": mode
                        }))
                    except Exception:
                        pass  # Connection might be closed, ignore
                else:
                    # Invalid mode
                    try:
                        await websocket.send(json.dumps({
                            "type": "error",
                            "message": f"Invalid mental state mode: {mode}"
                        }))
                    except Exception:
                        pass
            
            elif msg_type == "set_context":
                self.current_context = data.get("context", {})
            
            elif msg_type == "set_user":
                self.current_user_id = data.get("user_id", "default")
            
            elif msg_type == "start_recording":
                if not self.eeg_service.is_streaming:
                    try:
                        await websocket.send(json.dumps({
                            "type": "info",
                            "message": "Starting..."
                        }))
                    except Exception:
                        pass
                    
                    try:
                        # For synthetic board, no connection needed - just start streaming
                        if self.eeg_service.board_id == BoardIds.SYNTHETIC_BOARD:
                            if not self.eeg_service.board:
                                print("[SYNTHETIC] Initializing synthetic board...")
                                params = BrainFlowInputParams()
                                self.eeg_service.board = BoardShim(self.eeg_service.board_id, params)
                                self.eeg_service.board.prepare_session()
                                print("[SYNTHETIC] Board prepared successfully")
                            
                            if self.eeg_service.is_streaming:
                                try:
                                    await websocket.send(json.dumps({
                                        "type": "info",
                                        "message": "Streaming already in progress"
                                    }))
                                except Exception:
                                    pass
                                return
                            
                            print("[SYNTHETIC] Starting streaming...")
                            self.eeg_service.start_streaming(self.on_eeg_data)
                            
                            # Cancel existing stream task if any
                            if self.stream_task and not self.stream_task.done():
                                try:
                                    self.stream_task.cancel()
                                    await asyncio.wait_for(self.stream_task, timeout=1.0)
                                except (asyncio.CancelledError, asyncio.TimeoutError):
                                    pass
                            
                            self.stream_task = asyncio.create_task(self.eeg_service.stream_loop())
                            
                            # Send success message
                            try:
                                await websocket.send(json.dumps({
                                    "type": "recording_started",
                                    "message": "Synthetic board streaming started successfully"
                                }))
                            except Exception:
                                pass
                            
                            # Broadcast to all clients
                            try:
                                await self.broadcast({"type": "recording_started"})
                            except Exception:
                                pass
                            
                            print("[OK] Started streaming with synthetic board")
                            return
                        
                        # Real hardware connection logic would go here...
                        # (keeping it simple for now since we're using synthetic board)
                        
                    except Exception as e:
                        import traceback
                        error_msg = f"Failed to start: {str(e)}"
                        print(f"[ERROR] {error_msg}")
                        print(f"[ERROR] Traceback:\n{traceback.format_exc()}")
                        try:
                            await websocket.send(json.dumps({
                                "type": "error",
                                "message": error_msg
                            }))
                        except Exception:
                            pass
                else:
                    try:
                        await websocket.send(json.dumps({
                            "type": "info",
                            "message": "Recording already in progress"
                        }))
                    except Exception:
                        pass
            
            elif msg_type == "stop_recording":
                if self.eeg_service.is_streaming:
                    print("[WS] Stopping recording...")
                    try:
                        self.eeg_service.stop_streaming()
                        
                        # Cancel the stream task if it exists
                        if self.stream_task:
                            try:
                                self.stream_task.cancel()
                                await asyncio.wait_for(self.stream_task, timeout=2.0)
                            except (asyncio.CancelledError, asyncio.TimeoutError):
                                pass
                            self.stream_task = None
                        
                        # Send success message
                        try:
                            await websocket.send(json.dumps({
                                "type": "recording_stopped",
                                "message": "Recording stopped successfully"
                            }))
                        except Exception:
                            pass
                        
                        # Broadcast to all clients
                        try:
                            await self.broadcast({"type": "recording_stopped"})
                        except Exception:
                            pass
                        
                        print("[WS] Recording stopped successfully")
                    except Exception as stop_error:
                        import traceback
                        error_msg = f"Error stopping recording: {str(stop_error)}"
                        print(f"[ERROR] {error_msg}")
                        print(f"[ERROR] Traceback:\n{traceback.format_exc()}")
                        try:
                            await websocket.send(json.dumps({
                                "type": "error",
                                "message": error_msg
                            }))
                        except Exception:
                            pass
                else:
                    try:
                        await websocket.send(json.dumps({
                            "type": "info",
                            "message": "Not currently recording"
                        }))
                    except Exception:
                        pass
        
        except json.JSONDecodeError as e:
            error_msg = f"Invalid JSON: {str(e)}"
            print(f"[WS] JSON decode error: {error_msg}")
            try:
                await websocket.send(json.dumps({"type": "error", "message": error_msg}))
            except Exception:
                pass
        except Exception as e:
            import traceback
            error_msg = f"Error handling message: {str(e)}"
            print(f"[WS] Exception in handle_message: {error_msg}")
            print(f"[WS] Traceback:\n{traceback.format_exc()}")
            try:
                await websocket.send(json.dumps({"type": "error", "message": error_msg}))
            except Exception:
                pass
    
    async def on_eeg_data(self, combined_data: dict):
        """Callback when new EEG data is available - receives both raw channels and mental state"""
        try:
            if not combined_data:
                return
            
            raw_channels = combined_data.get("raw_channels")
            mental_state = combined_data.get("mental_state")
            
            if not raw_channels:
                return
            
            message = {
                "type": "eeg_data",
                "raw_channels": raw_channels,
                "mental_state": mental_state,  # Can be None
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            # Only broadcast if we have connected clients
            if len(self.connected_clients) > 0:
                try:
                    await self.broadcast(message)
                except Exception as broadcast_error:
                    print(f"[ERROR] Failed to broadcast EEG data: {broadcast_error}")
        except Exception as e:
            import traceback
            print(f"[ERROR] Error in on_eeg_data callback: {e}")
            print(f"[ERROR] Traceback:\n{traceback.format_exc()}")
    
    async def handle_client(self, websocket):
        """Handle a client connection"""
        await self.register_client(websocket)
        try:
            async for message in websocket:
                try:
                    await self.handle_message(websocket, message)
                except websockets.exceptions.ConnectionClosed:
                    break
                except Exception as e:
                    import traceback
                    print(f"[ERROR] Error processing message: {e}")
                    print(f"[ERROR] Traceback:\n{traceback.format_exc()}")
                    # Continue processing other messages
        except websockets.exceptions.ConnectionClosed:
            print(f"[CLIENT] Connection closed by client")
        except Exception as e:
            import traceback
            print(f"[ERROR] Error in handle_client: {e}")
            print(f"[ERROR] Traceback:\n{traceback.format_exc()}")
        finally:
            await self.unregister_client(websocket)
    
    def process_request(self, protocol, request):
        """Custom request processor to handle Connection header issues"""
        connection = request.headers.get("Connection", "")
        if connection and "upgrade" not in connection.lower():
            request.headers["Connection"] = "Upgrade"
        return None
    
    async def start(self):
        """Start the WebSocket server"""
        print(f"Starting WebSocket server on ws://{self.host}:{self.port}")
        async with websockets.serve(
            self.handle_client, 
            self.host, 
            self.port,
            process_request=self.process_request,
        ):
            await asyncio.Future()  # Run forever

if __name__ == "__main__":
    server = WebSocketServer()
    asyncio.run(server.start())
